<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.backbone API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.backbone</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># %%
import os
import random
import time
from datetime import datetime
from pathlib import Path

import matplotlib.pyplot as plt
import numpy
import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import *
from sklearn.metrics import plot_confusion_matrix
from sklearn.model_selection import (GridSearchCV, KFold, cross_val_score,
                                     train_test_split)
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeClassifier
from tqdm import tqdm

from .utils import *

# %%

label_array = {
    0: &#34;top&#34;,
    1: &#34;trouser&#34;,
    2: &#34;pullover&#34;,
    3: &#34;dress&#34;,
    4: &#34;coat&#34;,
    5: &#34;sandal&#34;,
    6: &#34;shirt&#34;,
    7: &#34;sneaker&#34;,
    8: &#34;bag&#34;,
    9: &#34;ankle_boot&#34;,
}


def return_shape(tes):
    print(tes.shape)


# %%


def print_shapes(arr):
    for i in arr:
        return_shape(i)


# %%


def visualize_image(features, res_path):
    for i in range(25):
        plt.subplot(5, 5, i + 1)
        plt.xticks([])
        plt.yticks([])
        plt.imshow(features[i].reshape(28, 28), cmap=&#34;gray&#34;)
    # plt.show()
    plt.savefig(f&#34;{res_path}/dataset_image.png&#34;)


# %%


def load_data(main_path, subset=None):
    df_train = pd.read_csv(str(main_path / &#34;fashion-mnist_train.csv&#34;))
    df_test = pd.read_csv(str(main_path / &#34;fashion-mnist_test.csv&#34;))
    print(df_train.head(5))

    if subset != None and subset &gt; 0:
        df_train = df_train.head(subset)
        df_test = df_test.head(subset)

    train_features, val_features, train_labels, val_labels = train_test_split(
        df_train.drop(&#34;label&#34;, axis=1), df_train[&#34;label&#34;], test_size=0.2
    )
    test_features, test_labels = df_test.drop(&#34;label&#34;, axis=1), df_test[&#34;label&#34;]
    (
        train_features,
        val_features,
        train_labels,
        val_labels,
        test_features,
        test_labels,
    ) = (
        train_features.to_numpy(),
        val_features.to_numpy(),
        train_labels.to_numpy(),
        val_labels.to_numpy(),
        test_features.to_numpy(),
        test_labels.to_numpy(),
    )
    print(&#34;[INFO] DONE LOADING DATA&#34;)
    return (
        train_features,
        val_features,
        train_labels,
        val_labels,
        test_features,
        test_labels,
    )


# %%
# ML PIPELINE


def return_process(im):
    list_of_procs = [np.flip, lambda x: x * 2, lambda x: x ** 2]
    return random.choice(list_of_procs)(
        im
    )  # TODO :add probability and every other transform


def preprocess_skeleton(array, labels, disable=False, sequential=True):
    # TODO : Append results to the array instead of replacing it
    # TODO : Use the labels to make sure it is correct after you append something
    if disable == True:
        return array, labels
    else:
        if sequential == True:
            # array = parallel(return_process, arr=array)
            array = np.array([return_process(x) for x in array])
            return array, labels
        else:
            array = parallel(return_process, arr=array)
            return array, labels


def dimensionality_reduction(X, X_test, method=&#34;pca&#34;):
    if method == &#34;pca&#34;:
        pca = PCA(0.85)
        pca.fit(X)
        X = pca.transform(X)
        X_test = pca.transform(X_test)


def train_and_predict(
    train_features,
    test_features,
    train_labels,
    test_labels,
    val_features,
    val_labels,
    model,
    metrics,
    res_path,
    reduce_dims=None,
    folds=10,
):
    # scale data
    train_features = np.concatenate(
        (train_features, test_features)
    )  # combining both here because k-fold will split them again into parts
    train_labels = np.concatenate((train_labels, test_labels))
    X = StandardScaler().fit_transform(train_features)
    X_test = StandardScaler().fit_transform(val_features)  # essentially validation set

    # preprocess_step
    X, train_labels = preprocess_skeleton(
        X, train_labels, disable=False
    )  # enable for processing

    visualize_image(X, res_path)
    if reduce_dims != None:
        dimensionality_reduction(X, X_test, reduce_dims)

    # k -fold
    dict_results = {x.__name__: [] for x in metrics}

    for metric in metrics:
        if metric.__name__ in [&#34;precision_score&#34;, &#34;f1_score&#34;, &#34;recall_score&#34;]:
            dict_results[metric.__name__] = np.mean(
                cross_val_score(
                    model,
                    X,
                    train_labels,
                    scoring=make_scorer(metric, average=&#34;micro&#34;),
                    cv=folds,
                    n_jobs=8,
                )
            )
        else:
            dict_results[metric.__name__] = np.mean(
                cross_val_score(
                    model,
                    X,
                    train_labels,
                    scoring=make_scorer(metric),
                    cv=folds,
                    n_jobs=8,
                )
            )

    print(dict_results)

    plt.cla()
    plt.clf()
    plot_confusion_matrix(model.fit(X, train_labels), X_test, val_labels)
    plt.savefig(f&#34;{res_path}/confusion_{str(model)}.png&#34;)

    return dict_results


def validation_stage(
    model_list,
    model_parameters,
    train_features,
    train_labels,
    test_features,
    test_labels,
):
    # Perform the Validation using Sklearn GridSearch
    model_best_params = []
    print(&#34;[INFO] Performing Validation&#34;)
    for i in range(len(tqdm(model_list))):
        print(&#34;[VALIDATION] %s model being validated\n&#34; % (model_list[i]))
        grid = GridSearchCV(
            model_list[i](), model_parameters[i], verbose=1, refit=True, n_jobs=12
        )
        grid.fit(train_features, train_labels)

        model_best_params.append(grid.best_params_)
        # model_best_params[model_list[i]] = grid.best_params_
        grid_predictions = grid.predict(test_features)

        print(classification_report(test_labels, grid_predictions))
        print(
            &#34;[VALIDATION] %s model validation completed\n&#34;
            &#34;==========================================\n&#34; % (model_list[i])
        )

    print(&#34;[INFO] Validation Stage Completed&#34;)

    return model_best_params


def multi_model_run(
    train_features,
    test_features,
    train_labels,
    test_labels,
    model_list,
    ##################
    model_parameters,
    ##################
    reduce_dims,
    metrics,
    res_path,
    val_features,
    val_labels,
    folds=10,
):

    ############################
    model_best_params = validation_stage(
        model_list,
        model_parameters,
        train_features,
        train_labels,
        test_features,
        test_labels,
    )

    print(&#34;[INFO] Applying Best Parameters to Models&#34;)
    for i in range(len(tqdm(model_list))):
        model_list[i] = model_list[i](**model_best_params[i])

    print(&#34;[INFO] Training and Testing Optimised Models&#34;)
    ############################

    final_dict_results = {}
    for model in tqdm(model_list):
        final_dict_results[str(model)] = train_and_predict(
            train_features=train_features,
            test_features=test_features,
            train_labels=train_labels,
            test_labels=test_labels,
            val_features=val_features,
            val_labels=val_labels,
            model=model,
            reduce_dims=reduce_dims,
            metrics=metrics,
            res_path=res_path,
            folds=folds,
        )
    print(final_dict_results)
    df = pd.DataFrame.from_dict(final_dict_results)
    df.to_csv(f&#34;{res_path}/outputs.csv&#34;, mode=&#34;a&#34;)
    return final_dict_results


# %%</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.backbone.dimensionality_reduction"><code class="name flex">
<span>def <span class="ident">dimensionality_reduction</span></span>(<span>X, X_test, method='pca')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimensionality_reduction(X, X_test, method=&#34;pca&#34;):
    if method == &#34;pca&#34;:
        pca = PCA(0.85)
        pca.fit(X)
        X = pca.transform(X)
        X_test = pca.transform(X_test)</code></pre>
</details>
</dd>
<dt id="src.backbone.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>main_path, subset=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(main_path, subset=None):
    df_train = pd.read_csv(str(main_path / &#34;fashion-mnist_train.csv&#34;))
    df_test = pd.read_csv(str(main_path / &#34;fashion-mnist_test.csv&#34;))
    print(df_train.head(5))

    if subset != None and subset &gt; 0:
        df_train = df_train.head(subset)
        df_test = df_test.head(subset)

    train_features, val_features, train_labels, val_labels = train_test_split(
        df_train.drop(&#34;label&#34;, axis=1), df_train[&#34;label&#34;], test_size=0.2
    )
    test_features, test_labels = df_test.drop(&#34;label&#34;, axis=1), df_test[&#34;label&#34;]
    (
        train_features,
        val_features,
        train_labels,
        val_labels,
        test_features,
        test_labels,
    ) = (
        train_features.to_numpy(),
        val_features.to_numpy(),
        train_labels.to_numpy(),
        val_labels.to_numpy(),
        test_features.to_numpy(),
        test_labels.to_numpy(),
    )
    print(&#34;[INFO] DONE LOADING DATA&#34;)
    return (
        train_features,
        val_features,
        train_labels,
        val_labels,
        test_features,
        test_labels,
    )</code></pre>
</details>
</dd>
<dt id="src.backbone.multi_model_run"><code class="name flex">
<span>def <span class="ident">multi_model_run</span></span>(<span>train_features, test_features, train_labels, test_labels, model_list, model_parameters, reduce_dims, metrics, res_path, val_features, val_labels, folds=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_model_run(
    train_features,
    test_features,
    train_labels,
    test_labels,
    model_list,
    ##################
    model_parameters,
    ##################
    reduce_dims,
    metrics,
    res_path,
    val_features,
    val_labels,
    folds=10,
):

    ############################
    model_best_params = validation_stage(
        model_list,
        model_parameters,
        train_features,
        train_labels,
        test_features,
        test_labels,
    )

    print(&#34;[INFO] Applying Best Parameters to Models&#34;)
    for i in range(len(tqdm(model_list))):
        model_list[i] = model_list[i](**model_best_params[i])

    print(&#34;[INFO] Training and Testing Optimised Models&#34;)
    ############################

    final_dict_results = {}
    for model in tqdm(model_list):
        final_dict_results[str(model)] = train_and_predict(
            train_features=train_features,
            test_features=test_features,
            train_labels=train_labels,
            test_labels=test_labels,
            val_features=val_features,
            val_labels=val_labels,
            model=model,
            reduce_dims=reduce_dims,
            metrics=metrics,
            res_path=res_path,
            folds=folds,
        )
    print(final_dict_results)
    df = pd.DataFrame.from_dict(final_dict_results)
    df.to_csv(f&#34;{res_path}/outputs.csv&#34;, mode=&#34;a&#34;)
    return final_dict_results</code></pre>
</details>
</dd>
<dt id="src.backbone.preprocess_skeleton"><code class="name flex">
<span>def <span class="ident">preprocess_skeleton</span></span>(<span>array, labels, disable=False, sequential=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_skeleton(array, labels, disable=False, sequential=True):
    # TODO : Append results to the array instead of replacing it
    # TODO : Use the labels to make sure it is correct after you append something
    if disable == True:
        return array, labels
    else:
        if sequential == True:
            # array = parallel(return_process, arr=array)
            array = np.array([return_process(x) for x in array])
            return array, labels
        else:
            array = parallel(return_process, arr=array)
            return array, labels</code></pre>
</details>
</dd>
<dt id="src.backbone.print_shapes"><code class="name flex">
<span>def <span class="ident">print_shapes</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_shapes(arr):
    for i in arr:
        return_shape(i)</code></pre>
</details>
</dd>
<dt id="src.backbone.return_process"><code class="name flex">
<span>def <span class="ident">return_process</span></span>(<span>im)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_process(im):
    list_of_procs = [np.flip, lambda x: x * 2, lambda x: x ** 2]
    return random.choice(list_of_procs)(
        im
    )  # TODO :add probability and every other transform</code></pre>
</details>
</dd>
<dt id="src.backbone.return_shape"><code class="name flex">
<span>def <span class="ident">return_shape</span></span>(<span>tes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_shape(tes):
    print(tes.shape)</code></pre>
</details>
</dd>
<dt id="src.backbone.train_and_predict"><code class="name flex">
<span>def <span class="ident">train_and_predict</span></span>(<span>train_features, test_features, train_labels, test_labels, val_features, val_labels, model, metrics, res_path, reduce_dims=None, folds=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train_and_predict(
    train_features,
    test_features,
    train_labels,
    test_labels,
    val_features,
    val_labels,
    model,
    metrics,
    res_path,
    reduce_dims=None,
    folds=10,
):
    # scale data
    train_features = np.concatenate(
        (train_features, test_features)
    )  # combining both here because k-fold will split them again into parts
    train_labels = np.concatenate((train_labels, test_labels))
    X = StandardScaler().fit_transform(train_features)
    X_test = StandardScaler().fit_transform(val_features)  # essentially validation set

    # preprocess_step
    X, train_labels = preprocess_skeleton(
        X, train_labels, disable=False
    )  # enable for processing

    visualize_image(X, res_path)
    if reduce_dims != None:
        dimensionality_reduction(X, X_test, reduce_dims)

    # k -fold
    dict_results = {x.__name__: [] for x in metrics}

    for metric in metrics:
        if metric.__name__ in [&#34;precision_score&#34;, &#34;f1_score&#34;, &#34;recall_score&#34;]:
            dict_results[metric.__name__] = np.mean(
                cross_val_score(
                    model,
                    X,
                    train_labels,
                    scoring=make_scorer(metric, average=&#34;micro&#34;),
                    cv=folds,
                    n_jobs=8,
                )
            )
        else:
            dict_results[metric.__name__] = np.mean(
                cross_val_score(
                    model,
                    X,
                    train_labels,
                    scoring=make_scorer(metric),
                    cv=folds,
                    n_jobs=8,
                )
            )

    print(dict_results)

    plt.cla()
    plt.clf()
    plot_confusion_matrix(model.fit(X, train_labels), X_test, val_labels)
    plt.savefig(f&#34;{res_path}/confusion_{str(model)}.png&#34;)

    return dict_results</code></pre>
</details>
</dd>
<dt id="src.backbone.validation_stage"><code class="name flex">
<span>def <span class="ident">validation_stage</span></span>(<span>model_list, model_parameters, train_features, train_labels, test_features, test_labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validation_stage(
    model_list,
    model_parameters,
    train_features,
    train_labels,
    test_features,
    test_labels,
):
    # Perform the Validation using Sklearn GridSearch
    model_best_params = []
    print(&#34;[INFO] Performing Validation&#34;)
    for i in range(len(tqdm(model_list))):
        print(&#34;[VALIDATION] %s model being validated\n&#34; % (model_list[i]))
        grid = GridSearchCV(
            model_list[i](), model_parameters[i], verbose=1, refit=True, n_jobs=12
        )
        grid.fit(train_features, train_labels)

        model_best_params.append(grid.best_params_)
        # model_best_params[model_list[i]] = grid.best_params_
        grid_predictions = grid.predict(test_features)

        print(classification_report(test_labels, grid_predictions))
        print(
            &#34;[VALIDATION] %s model validation completed\n&#34;
            &#34;==========================================\n&#34; % (model_list[i])
        )

    print(&#34;[INFO] Validation Stage Completed&#34;)

    return model_best_params</code></pre>
</details>
</dd>
<dt id="src.backbone.visualize_image"><code class="name flex">
<span>def <span class="ident">visualize_image</span></span>(<span>features, res_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_image(features, res_path):
    for i in range(25):
        plt.subplot(5, 5, i + 1)
        plt.xticks([])
        plt.yticks([])
        plt.imshow(features[i].reshape(28, 28), cmap=&#34;gray&#34;)
    # plt.show()
    plt.savefig(f&#34;{res_path}/dataset_image.png&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.backbone.dimensionality_reduction" href="#src.backbone.dimensionality_reduction">dimensionality_reduction</a></code></li>
<li><code><a title="src.backbone.load_data" href="#src.backbone.load_data">load_data</a></code></li>
<li><code><a title="src.backbone.multi_model_run" href="#src.backbone.multi_model_run">multi_model_run</a></code></li>
<li><code><a title="src.backbone.preprocess_skeleton" href="#src.backbone.preprocess_skeleton">preprocess_skeleton</a></code></li>
<li><code><a title="src.backbone.print_shapes" href="#src.backbone.print_shapes">print_shapes</a></code></li>
<li><code><a title="src.backbone.return_process" href="#src.backbone.return_process">return_process</a></code></li>
<li><code><a title="src.backbone.return_shape" href="#src.backbone.return_shape">return_shape</a></code></li>
<li><code><a title="src.backbone.train_and_predict" href="#src.backbone.train_and_predict">train_and_predict</a></code></li>
<li><code><a title="src.backbone.validation_stage" href="#src.backbone.validation_stage">validation_stage</a></code></li>
<li><code><a title="src.backbone.visualize_image" href="#src.backbone.visualize_image">visualize_image</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>